# -*- coding: utf-8 -*-
"""SudokuDefinitivo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J_Dq8jMctINRot_kUlG359_IjldEgVUI
"""

#Solución de sudokus usando backtracking cronológico
#Autores: Juan Camilo Castro, Daniel Peláez Chica


Vars={}   #Diccionario vacío
#------------------------------------------------------------------------------------------------------------------
#Asignación del rango de variables
def defVarsRange(Vars):
  rows=set(range(1,10))
  cols=['A','B','C','D','E','F','G','H','I']
  for c in cols:
    for r in rows:
      Vars[c+str(r)]=rows.copy()

def setValue(Vars,Name,Value):
  Vars[Name]={Value}
#------------------------------------------------------------------------------------------------------------------
#Restricciones de ariedad 9
def ca9NE(Vars,listVars):
  for i in listVars:
    if(len(Vars[i])==1):
      for j in listVars:
        if(not(i==j)):
          Vars[j].discard(list(Vars[i])[0]) #descarta posibles valores para que sea único en una celda
#------------------------------------------------------------------------------------------------------------------
#Restricciones del sudoku
def setConstraints(Const):
  rows=set(range(1,10))
  cols=['A','B','C','D','E','F','G','H','I']
  
  listVars=[]
  for r in rows: #Restricción de filas
    for c in cols:
      listVars.append(c+str(r))
    Const.append(['ca9NE',listVars.copy()])
    listVars=[]

  for c in cols: #Restricción de columnas
    for r in rows:
      listVars.append(c+str(r))
    Const.append(['ca9NE',listVars.copy()])
    listVars=[]

  for n in range(0,10,3): #Restricción de ventanas
        cont = 1
        for c in cols:
            for r in rows:
                if(r>n and r<n+4):
                    listVars.append(c+str(r))
                    cont = cont + 1
            if (cont==10):
                Const.append(['ca9NE',listVars.copy()])
                cont = 1
                listVars=[]
#------------------------------------------------------------------------------------------------------------------
#Definición de variables y restricciones
Const=[]
defVarsRange(Vars)
setConstraints(Const)
#------------------------------------------------------------------------------------------------------------------
#Extraer info del archivo
def bringdata(stored):
  file = open(stored, "r")
  ListSudoku = "ABCDEFGHI"
  for i in range(1,10): #Lectura línea a línea
    for j in ListSudoku:
      cur=int(file.readline())
      if(cur<10):
        setValue(Vars,str(j)+str(i),cur)
#------------------------------------------------------------------------------------------------------------------
#Evalua la consistencia de un posible valor
def consistente(celda, valor):
  for iConst in Const:
    if celda in iConst[1]:
      for dato in iConst[1]:
        if(Vars[dato]=={valor} and len(Vars[dato])==1 and dato!=celda):
          return False
  return True
#------------------------------------------------------------------------------------------------------------------
#Funciones de disyunción
def eliminarCols():
  cols=['A','B','C','D','E','F','G','H','I']
  for c in cols:
    for r in range(1, 10):
        aux1=Vars[c+str(r)]
        noRept=aux1.copy()
        for s in range(1, 10):
            if [c+str(r)] != [c+str(s)]:
                aux2=Vars[c+str(s)]
                for x in aux1:
                    if x in aux2 and x in noRept:
                        noRept.remove(x)
        if len(noRept) != 0:
            Vars[c+str(r)]=noRept.copy()
#------------------------------------------------------------------------------------------------------------------
def eliminarFilas():
  cols=['A','B','C','D','E','F','G','H','I']
  for r in range(1,10):
    for c in cols:
        aux1=Vars[c+str(r)]
        noRept=aux1.copy()
        for s in cols:
            if [s+str(r)] != [c+str(r)]:
                aux2=Vars[s+str(r)]
                for x in aux1:
                    if x in aux2 and x in noRept:
                        noRept.remove(x)
        if len(noRept) != 0:
            Vars[c+str(r)]=noRept.copy()
#------------------------------------------------------------------------------------------------------------------
#Solución del sudoku a través de backtracking cronológico
def backtracking():
  for celda in Vars:
    if len(Vars[celda]) != 1:
      for valor in range(1,10):
        if consistente(celda, valor):
          Vars[celda]={valor}
          if backtracking():
            return True
          else:
            Vars[celda]=set(range(1,10))
      return False
  return True

bringdata("sample_data/fuerte.txt")
for i in range(5):
  for iConst in Const:
    eval(iConst[0])(*[Vars,iConst[1]])
  eliminarCols()
  eliminarFilas()
backtracking()
print(Vars)